#ifndef _rt_H
#define _rt_H

//These include basic math and vector support, as well as
//a helper library for OpenGL.
//For the Java developers amongst you, this is slightly similar
//to an import statement in Java.
#include <cmath>
#include <vector>
#include <GL/glut.h>

//this allows you to not have to write the std namespace before each
//function from the std library.
//for instance: std::vector becomes vector.
using namespace std; 

// -- forward declarations of the classes --
//Vector3f is a class to store 3 values, often used for x,y,z coordinates 
class Vector3f;

//the Triangle class stores an index to 3 vertices. These are internally stored
//as indices to a vector of vertices (which are Vector3f).
class Triangle;

//The TriangleMesh class actually stores the geometry of an object.
//It stores the vertices and a list of triangles (indices into the vertex list).
class TriangleMesh;

//--- Definitions for the classes ---
class Vector3f {

	
	
	
	public:

	float _item[3];//item internally stores the 3 floating point values
	vector<int> relatedTriangles;
	float _nx, _ny, _nz;
	float count;
	void addNormal(float x, float y, float z) 
	{
		//std::cout<<"ADDING NORMAL " <<x<<" "<<y<<" "<<z<<" "<<std::endl;
		_nx += x;
		_ny += y;
		_nz += z;
		count += 1;
	}



	//A Vector3f is indexed like an array, with a range of 0 to 2.
	//When we are using these for cartesian coordinates, index 0 is
	//the x coordinate, 1 is y, and 2 is z.
	float & operator [] (int i) {
		return _item[i];
    	}

	//a constructor for the Vector3f class. 
	Vector3f(float x, float y, float z) 
	{  _item[0] = x ; _item[1] = y ; _item[2] = z; };

	//Another constructor, initialising to 0,0,0
	Vector3f() 
	{
		_item[0] = 0.0f ; _item[1] = 0.0f ; _item[2] = 0.0f; 
	}
	void print()
	{
		std::cout<<_item[0] << ", " << _item[1] << ", " << _item[2] << std::endl;
	}

	void addTriangle(int t) {
		relatedTriangles.push_back(t);
	}

	void getNormal(Vector3f& toFill)
	{
		if(count < 1) {
			std::cout<<"AVERAGE NORMAL ERROR"<<std::endl;
			return;
		}
		//std::cout<<_nx<<" "<<_ny<<" "<<_nz<<" "<<count<<std::endl;
		toFill[0] = _nx/(float)count;
		toFill[1] = _ny/(float)count;
		toFill[2] = _nz/(float)count;
		//std::cout<<"NORM "<<toFill[0] <<" "<<toFill[1]<<" "<<toFill[2]<<std::endl;
	}

	/*
	void computeNormal(vector<Vector3f>& _v, vector<Triangle>& _trig)
	{
		
		for(int i = 0; i < relatedTriangles.size(); i++) {
			Vector3f norm;
			int trig = relatedTriangles[i];
			Vector3f& a = _v[_trig[trig]._vertex[0]];
			Vector3f& b = _v[_trig[trig]._vertex[1]];
			Vector3f& c = _v[_trig[trig]._vertex[2]];
			Operations::FaceNormal(norm, a, b, c);
			norm.Normalise();
			normalList.push_back(norm);
		}		
		float nx, ny, nz = 0;
		for(int j = 0; j < normalList.size(); j++) {
				nx += normalList[j][0];
				ny += normalList[j][1];
				nz += normalList[j][2];
		}
		fnx = nx;
		fny = ny;
		fnz = nz;
	}
	*/
	void Normalise()
	{

		float x, y, z = 0;
		x = _item[0];
		y = _item[1];
		z = _item[2];
		if(x*x+y*y+z*z <= 1.1){return;}
		if(_item[0]==0 && _item[1]==0 && _item[2]==0) {std::cout<<"NULL VECTOR"<<std::endl;return;}
		//std::cout<<"Attempting to normalise: "<<x<<" "<<y<<" "<<z<<std::endl;
		if(x*x==0){std::cout<<"x null"<<std::endl;}
		if(y*y==0){std::cout<<"y null"<<std::endl;}
		//if(z*z==0){std::cout<<"z null"<<std::endl;}
		double length = sqrt((x * x) + (y * y) + (z*z));
		if(length == 0) {std::cout<<"NORMALISATION ERROR  "<<x<<" "<<y<<" "<<z<<std::endl;return;}
		_item[0] = x/length;
		_item[1] = y/length;
		_item[2] = z/length;
	}

	Vector3f & operator = (Vector3f & obj) 
	{
		_item[0] = obj[0];
		_item[1] = obj[1];
		_item[2] = obj[2];

		return *this;
	}

	Vector3f & operator += (Vector3f & obj) 
	{
		_item[0] += obj[0];
		_item[1] += obj[1];
		_item[2] += obj[2];

		return *this;
	}
};

//An output stream, useful for debugging.
//Allows you to stream Vector3f objects to the terminal.
ostream & operator << (ostream & stream, Vector3f & obj) 
{
	stream << obj[0] << ' ' << obj[1] << ' ' << obj[2] << ' ';
}




class Triangle {
friend class TriangleMesh;
friend class Vector3f;

	int _vertex[3];//indices to the 3 vertices of the triangle
public:
	Vector3f normal;
	Triangle(int v1, int v2, int v3) 
	{
		_vertex[0] = v1;  _vertex[1] = v2;  _vertex[2] = v3;  
	}
};

//Utilities
//fmax returns the maximum of 3 floats
float fmax(float f1,float f2, float f3) {
	float f = f1;

	if (f < f2) f = f2;
	if (f < f3) f = f3;

	return f;
}

//fmin returns the minimum of 3 floats.
float fmin(float f1,float f2, float f3) {
	float f = f1;

	if (f > f2) f = f2;
	if (f > f3) f = f3;

	return f;
}


class TriangleMesh 
{
	vector <Vector3f> _v; //_v stores the vertices as Vector3f
	vector <Triangle> _trig; //_trig stores the triangles as instances of the Triangle class
	
	float _xmax, _xmin, _ymax, _ymin, _zmin, _zmax;//These store the bounding values for each axis.

public: 
	TriangleMesh(char * filename) { loadFile(filename) ;};
	TriangleMesh() {};
	void loadFile(char * filename);

	int trigNum() { return _trig.size() ;};
	int vNum() { return _v.size();};
	Vector3f v(int i) { return _v[i];};

	//v1, v2 and v3 are return values for the vertices. i is the input index.
	void getTriangleVertices(int i, Vector3f & v1, Vector3f & v2, Vector3f & v3)
	{
		v1 = _v[_trig[i]._vertex[0]]; v1.count = _v[_trig[i]._vertex[0]].count;
		v2 = _v[_trig[i]._vertex[1]]; v2.count = _v[_trig[i]._vertex[1]].count;
		v3 = _v[_trig[i]._vertex[2]]; v3.count = _v[_trig[i]._vertex[2]].count;
	};

	void preComputeNormals();
			
};


class Operations
{
public:

		static float DotProduct(Vector3f& vec1, Vector3f& vec2)
		{
			return (vec1[0]*vec2[0] + vec1[1]*vec2[1] + vec1[2]*vec2[2] );
		};

		static double f(Vector3f& a, Vector3f& b, int x, int y)
		{
			return ((double)a[1] - (double)b[1])*(double)x + ((double)b[0] - (double)a[0])*(double)y + (double)a[0]*(double)b[1] - (double)b[0]*(double)a[1];
		};

		static void Barycentric(Vector3f& bar, Vector3f& v0, Vector3f& v1, Vector3f& v2, int x, int y)
		{
			bar[0] = f(v1, v2, x, y)/f(v1, v2, v0[0], v0[1]);
			bar[1] = f(v2,v0,x,y)/f(v2,v0,v1[0], v1[1]);
			bar[2] = f(v0,v1,x,y)/f(v0,v1,v2[0], v2[1]);
			//bar[2] = 1 - b[0] - b[1];

			double alpha, beta, gamma = 0;
			double _x = (double)x;
			double _y = (double)y;
			double x0 = v0[0]; double y0 = v0[1];
			double x1 = v1[0]; double y1 = v1[1];
			double x2 = v2[0]; double y2 = v2[1];

			alpha = ((y1-y2)*_x + (x2-x1)*_y + x1*y2 - x2*y1) / ((y1-y2)*x0 + (x2-x1)*y0 + x1*y2 - x2*y1);
			beta = ((y2-y0)*_x + (x0-x2)*_y + x2*y0 - x0*y2) / ((y2-y0)*x1 + (x0-x2)*y1 + x2*y0 - x0*y2);
			//gamma = ((y0-y1)*_x + (x1-x0)*_y + x0*y1 - y1*x0) / ((y0-y1)*x2 + (x1-x0)*y2 + x0*y1 - y1*x0);
			gamma = 1 - alpha - beta;
			//std::cout<<"x: "<<x<<" y: "<<y<<"  "<<alpha+beta+gamma<<"   "<<bar[0]+bar[1]+bar[2]<<std::endl;

			bar[0] = alpha;
			bar[1] = beta;
			bar[2] = gamma;

		};

		static float MinX(Vector3f& v1, Vector3f& v2, Vector3f& v3)
		{
			float min = v1[0];
			if(v2[0] < min)
			{
				min = v2[0];
			}
			if(v3[0] < min)
			{
				min = v3[0];
			}
			return (min);
		};

		static float MinY(Vector3f& v1, Vector3f& v2, Vector3f& v3)
		{
			float min = v1[1];
			if(v2[1] < min)
			{
				min = v2[1];
			}
			if(v3[1] < min)
			{
				min = v3[1];
			}
			return (min);
		};

		static float MaxX(Vector3f& v1, Vector3f& v2, Vector3f& v3)
		{
			float max = v1[0];
			if(v2[0] > max)
			{
				max = v2[0];
			}
			if(v3[0] > max)
			{
				max = v3[0];
			}
			return (max);
		};

		static float MaxY(Vector3f& v1, Vector3f& v2, Vector3f& v3)
		{
			float max = v1[1];
			if(v2[1] > max)
			{
				max = v2[1];
			}
			if(v3[1] > max)
			{
				max = v3[1];
			}
			return (max);
		};

		static void CrossProduct(Vector3f& res, Vector3f& a, Vector3f& b)
		{
			res[0] = a[1]*b[2] - a[2]*b[1];
			res[1] = a[2]*b[0] - a[0]*b[2];
			res[2] = a[0]*b[1] - a[1]*b[0];
		};
		static void FaceNormal(Vector3f& normal, Vector3f& v1, Vector3f& v2, Vector3f& v3)
		{
			Vector3f a(v2[0]-v1[0], v2[1]-v1[1], v2[2] - v1[2]);
			Vector3f b(v3[0]-v1[0], v3[1]-v1[1], v3[2] - v1[2]);
			CrossProduct(normal, a, b);
		};
};

class Lighting
{
	public:
		static float phongIllumination(Vector3f& point, Vector3f& norm, float ka, float kd, float ks, float Ia, int n, int rgb) 
		{
			float ambientLight = 0.8f;
			float lightIntensity = 0.5f;
			float reflect = 0.5f;
			Vector3f light(0.5,0.5f,0);

			float result = ambientLight* ka;
			
			result += lightIntensity*(kd*Operations::DotProduct(norm, light));

			

			return abs(result);
			 
		}

};



class Transformations
{
	public:
	static void Translate(Vector3f& vec, double x, double y, double z) 
	{
		

		double xa,ya,za,wa = 0;

		xa = 1*vec[0] + 0*vec[1] + 0*vec[2] + vec[3]*x;
		ya = 0*vec[0] + 1*vec[1] + 0*vec[2] + vec[3]*y;
		za = 0*vec[0] + 0*vec[1] + 1*vec[2] + vec[3]*z;
		wa = 0*vec[0] + 0*vec[1] + 0*vec[2] + vec[3]*1;
		
		vec[0] = xa;
		vec[1] = ya;
		vec[2] = za;
		vec[3] = wa;

	}
	
	static void Project(float focal, Vector3f& a, Vector3f& c)
	{
		//a[0] = (a[0] - c[0]) /(-focal * a[2] + 1);
		//a[1] = (a[1] - c[1]) /(-focal * a[2] + 1);
		a[0] = ((a[0] - c[0]) * focal) / (-a[2] + focal);
		a[1] = ((a[1] - c[1]) * focal) / (-a[2] + focal);
	}
	
	
	static void Scale(Vector3f& vec, double x, double y, double z)
	{
		double xa, ya, za = 0;
		vec[0] *= x;
		vec[1] *= y;
		vec[2] *= z;

	}

	static void RotX(Vector3f& vec, double angle)
	{
		double cosa = cos(angle);
		double sina = sin(angle);
		double xa, ya, za, wa = 0;
		xa = 1*vec[0] + 0*vec[1] + 0*vec[2] + 0*vec[3];
		ya = 0*vec[0] + cosa*vec[1] - sina*vec[2] + 0*vec[3];
		za = 0*vec[0] + sina*vec[1] + cosa*vec[2] + 0*vec[3];
		wa = 0*vec[0] + 0*vec[1] + 0*vec[2] + 1*vec[3];
		vec[3] = wa;
		vec[0] = xa;
		vec[1] = ya;
		vec[2] = za;
	}
	
	
	static void RotY(Vector3f& vec, double angle)
	{
		double cosa = cos(angle);
		double sina = sin(angle);
		double xa, ya, za, wa = 0;
		xa = cosa*vec[0] + 0*vec[1] + sina*vec[2] + 0*vec[3];
		ya = 0*vec[0] + 1*vec[1] + 0*vec[2] + 0*vec[3];
		za = -sina*vec[0] + 0*vec[1] + cosa*vec[2] + 0*vec[3];
		wa = 0*vec[0] + 0*vec[1] + 0*vec[2] + 1*vec[3];
		vec[3] = wa;
		vec[0] = xa;
		vec[1] = ya;
		vec[2] = za;
		
	}
	
	static void RotZ(Vector3f& vec, double angle)
	{
		double cosa = cos(angle);
		double sina = sin(angle);
		double xa, ya, za, wa = 0;
		xa = cosa*vec[0] - sina*vec[1] + 0*vec[2] + 0*vec[3];
		ya = sina*vec[0] + cosa*vec[1] + 0*vec[2] + 0*vec[3];
		za = 0*vec[0] + 0*vec[1] + 1*vec[2] + 0*vec[3];
		wa = 0*vec[0] + 0*vec[1] + 0*vec[2] + 1*vec[3];
		vec[3] = wa;
		vec[0] = xa;
		vec[1] = ya;
		vec[2] = za;
	}


	static void Rotate(Vector3f& vec, double rotx, double roty, double rotz)
	{
		RotX(vec, rotx);
		RotY(vec, roty);
		RotZ(vec, rotz);
	}

	static void Transform(Vector3f& v1, Vector3f& v2, Vector3f& v3, double x, double y, double z, double rotx, double roty, double rotz)
	{
		Rotate(v1, rotx, roty, rotz);
		Rotate(v2, rotx, roty, rotz);
		Rotate(v3, rotx, roty, rotz);

		Translate(v1, x,y,z);
		Translate(v2, x,y,z);
		Translate(v3, x,y,z);
	}
};

#endif //_rt_H
