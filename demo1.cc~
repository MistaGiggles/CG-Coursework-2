#include <iostream>
#include <fstream>
#include <cstring>
#include <GL/glut.h>
#include "demo1.h"
#include <float.h>

using namespace std;

//window resolution (default 640x480)
const int nRows = 640;
const int nCols = 480; 

double yaw = 0;
double roll = 0;
double pitch = 0;
double xmod, ymod, zmod  = 0;
double scalemod = 1;
int mode = 0;
bool once = false;


float foc  = 0;

//The mesh global variable
TriangleMesh trig;

//This function loads an obj format file
//This is a utility and should not have to be modified for teapot.obj (the assignment).
void TriangleMesh::loadFile(char * filename)
{
	ifstream f(filename); // the file stream, for reading in a file

	//if the file was unabled to be opened (ifstream pointer is NULL), exit with error message.
	if (f == NULL) {
		cerr << "failed reading polygon data file: " << filename << endl;
		exit(1);
	}

	char buf[1024];
	char header[100];
	float x,y,z;
	float xmax,ymax,zmax,xmin,ymin,zmin;
	int v1, v2, v3, n1, n2, n3;

	xmax =-10000; ymax =-10000; zmax =-10000;
	xmin =10000; ymin =10000; zmin =10000;
	Vector3f av;
	av[0] = av[1] = av[2] = 0.f;

	while (!f.eof()) {
		    f.getline(buf, sizeof(buf));
		    sscanf(buf, "%s", header);  

		    if (strcmp(header, "v") == 0) {
				sscanf(buf, "%s %f %f %f", header, &x, &y, &z);  

				_v.push_back(Vector3f(x,y,z));

				av[0] += x; av[1] += y; av[2] += z;

				if (x > xmax) xmax = x;
				if (y > ymax) ymax = y;
				if (z > zmax) zmax = z;

				if (x < xmin) xmin = x;
				if (y < ymin) ymin = y;
				if (z < zmin) zmin = z;
		    }
		    else if (strcmp(header, "f") == 0) {
				sscanf(buf, "%s %d %d %d", header, &v1, &v2, &v3);
				
				Triangle trig(v1-1, v2-1, v3-1);
				_trig.push_back(trig);
				_v[v1-1].relatedTriangles.push_back(_trig.size() -1);
				_v[v2-1].relatedTriangles.push_back(_trig.size() -1);
				_v[v3-1].relatedTriangles.push_back(_trig.size() -1);
		    }
 	}

	_xmin = xmin; _ymin = ymin; _zmin = zmin;
	_xmax = xmax; _ymax = ymax; _zmax = zmax;

	float range; 
	if (xmax-xmin > ymax-ymin) range = xmax-xmin;
	else range = ymax-ymin;

	for (int j = 0; j < 3; j++) av[j] /= _v.size();

	for (int i = 0; i < _v.size(); i++) 
	{
		for (int j = 0; j < 3; j++) _v[i][j] = (_v[i][j]-av[j])/range*400;  
	}
	cout << "Number of triangles: " << _trig.size() << ", number of vertices: " << _v.size() << endl;
	f.close();
	preComputeNormals();

};

void TriangleMesh::preComputeNormals() 
{
	;
	for(int v = 0; v < _v.size(); v++)
		{
			
			for(int i = 0; i < _v[v].relatedTriangles.size(); i++) {
				
				Vector3f norm;
				int trig = _v[v].relatedTriangles[i];
				Vector3f& a = _v[_trig[trig]._vertex[0]];
				Vector3f& b = _v[_trig[trig]._vertex[1]];
				Vector3f& c = _v[_trig[trig]._vertex[2]];
				
				Operations::FaceNormal(norm, a, b, c);
				norm.Normalise();
				_trig[trig].normal[0] = norm[0];
				_trig[trig].normal[1] = norm[1];
				_trig[trig].normal[2] = norm[2];
				_v[v].addNormal(norm[0], norm[1], norm[2]);
				
			}
			
					
					
			
			if(v < 10) {
				Vector3f out;
				_v[v].getNormal(out);
				//std::cout<<v<<" OUT: "<<out[0]<<", "<<out[1]<<", "<<out[2]<<std::endl;
				out.Normalise();
				//std::cout<<v<<" OUT: "<<out[0]<<", "<<out[1]<<", "<<out[2]<<std::endl;
			}
		}

		for(int c = 0; c < _v.size(); c++)
		{
			if(_v[c].count < 1) 
			{
				std::cout<<"Vertex "<<c<<" has no associated triangles"<<std::endl;
			}
		}
}

/*--- Display Function ---*/
//The main display function.
//This allows you to draw pixels onto the display by using GL_POINTS.
//Drawn every time an update is required.
//Students: This is the main file you'll need to modify or replace.
//The idea with this example function is the following:
//1)Clear the screen so we can draw a new frame
//2)Calculate the vertex points for each triangle and draw them (vertices only)
//3)Flush the pipeline so that the instructions we gave are performed.
void demoDisplay()
{
	if(once){return;}
	Vector3f lightDirection(-0.5,0.5,-0.5);
	double zbuffer[nRows][nCols];
	for(int i = 0; i < nRows; i++) {
		for(int j= 0; j < nCols; j++) {
			zbuffer[i][j] = FLT_MAX;
		}
	}
	glClear(GL_COLOR_BUFFER_BIT); // Clear OpenGL Window

	int trignum = trig.trigNum(); //Number of triangles
	Vector3f v1,v2,v3; // Vector objects to hold the returned vertex values

	glColor3f(1,1,1);  // The colour we will be drawing is white (red = 1, green = 1, blue = 1).

	//
	// for each triangle, get the location of the vertices,
	// project them on the xy plane (remove z value), and color the corresponding pixel white
	//
	for (int i = 0 ; i < trignum; i++)  
	{
		/* getting the vertices of the triangle i */
		trig.getTriangleVertices(i, v1,v2,v3); //For the Java programmers, v1,v2 and v3 are the return values here.

		//
		// An example:
		// Colouring the pixels at the vertex location 
		// (just doing parallel projectiion to the xy plane.) 
		// students: only use glBegin(GL_POINTS) for rendering the scene  
		// GL_LINES, GL_POLYGONS and similar may NOT be used in your submission.
		//

		//Vector3f a1(v1);
		//Vector3f a2(v2);
		//Vector3f a3(v3);
		Vector3f a1(v1[0], v1[1], v1[2]);
		Vector3f a2(v2[0], v2[1], v2[2]);
		Vector3f a3(v3[0], v3[1], v3[2]);

		Transformations::Rotate(a1, roll, yaw, pitch);
		Transformations::Rotate(a2, roll, yaw, pitch);
		Transformations::Rotate(a3, roll, yaw, pitch);


		glBegin(GL_POINTS);	
			//glVertex2i((int)v1[0],(int)v1[1]);
			//glVertex2i((int)v2[0],(int)v2[1]);
			//glVertex2i((int)v3[0],(int)v3[1]);
			for(int x = Operations::MinX(a1, a2, a3); x <= Operations::MaxX(a1,a2,a3); x++)
					{
						for(int y = Operations::MinY(a1, a2, a3); y <=Operations::MaxY(a1, a2, a3); y++)
						{
							Vector3f bar(0,0,0);
							Operations::Barycentric(bar, a1, a2, a3, x, y);
							//std::cout<<bar[0] + bar[1] + bar[2]<<std::endl;
							bool inside = bar[0]>=0 && bar[0]<=1 && bar[1] >= 0 && bar[1] <= 1 && bar[2] >= 0 && bar[2] <= 1;
							if(inside) {
								
								double  depth = a1[2]*bar[0] + a2[2]*bar[1] + a2[2]*bar[2];
								//std::cout<<x<<" "<<y<<" "<<depth<<std::endl;
								int screenx = x + nCols/2;
								int screeny = y + nRows/2;
								if(zbuffer[screenx][screeny] > depth) 
								{
									
									zbuffer[screenx][screeny] = depth;
									if(mode==0) 
									{
										Vector3f FaceNorm(0,0,0);
										Operations::FaceNormal(FaceNorm, a1, a2, a3);
										FaceNorm.Normalise();
										float color = Lighting::phongIllumination(FaceNorm, FaceNorm, 0.45f, 0.45f, 0.45f, 0.35f, 1, 1);
										//std::cout<<"COLOR: "<<color<<" "<<std::endl;

										color = abs(color);
										if(FaceNorm[2] == 0) {
											glColor3f(0, 0, color);
										}
										if(FaceNorm[2] > 0) {
										
											glColor3f(color, 0, 0);
										}
										
										if(FaceNorm[2] < 0) {
										
											glColor3f(0, color, 0);
										}
										
										glVertex2i(x, y);
									}
									if(mode==1)
									{
										Vector3f na1(1,1,1);
										Vector3f na2(1,1,1);
										Vector3f na3(1,1,1);

										v1.getNormal(na1);
										v2.getNormal(na2);
										v3.getNormal(na3);

										//Transformations::Rotate(na1, roll, yaw, pitch);
										//Transformations::Rotate(na2, roll, yaw, pitch);
										//Transformations::Rotate(na3, roll, yaw, pitch);


										//na1.Normalise();
										//na2.Normalise();
										//na3.Normalise();
										

										float color1 = Lighting::phongIllumination(na1, na1, 0.15f, 0.15f, 0.45f, 0.35f, 1, 1);
										float color2 = Lighting::phongIllumination(na2, na2, 0.15f, 0.15f, 0.45f, 0.35f, 1, 1);
										float color3 = Lighting::phongIllumination(na3, na3, 0.45f, 0.15f, 0.45f, 0.35f, 1, 1);
										float res = bar[0]*color1 + bar[1]*color2 + bar[2]*color3;
										std::cout<<"COLOR: "<<color1<<" "<<color2<<" "<<color3<<" "<<res<<" "<<std::endl;
										//res = (res);

										
										glColor3f(res, 0, 0);
										
										glVertex2i(x, y);

									}

									
								}
								
							}
						}
					}
		glEnd();	
	}
	once = false;
	glFlush();// Output everything (write to the screen)
}


//This function is called when a (normal) key is pressed
//x and y give the mouse coordinates when a keyboard key is pressed
void demoKeyboardHandler(unsigned char key, int x, int y)
{
    if(key == 'm')
    {
        cout << "Mouse location: " << x << " " << y << endl;
    }

    cout << "Key pressed: " << key << endl;

}
void processSpecialKeys(int key, int x, int y) {

	int mod = glutGetModifiers();
	switch(mod) {
		case GLUT_ACTIVE_CTRL :
			switch(key) {
				case GLUT_KEY_UP :
					ymod += 1;
					
					break;
				case GLUT_KEY_DOWN :
					ymod -= 1;
					
					break;
				case GLUT_KEY_RIGHT :
					xmod +=1 ;
					
					break;
		
				case GLUT_KEY_LEFT :
					xmod -= 1;
					
					break;
				case GLUT_KEY_PAGE_UP:
					zmod += 10;
					
					break;
				
				case GLUT_KEY_PAGE_DOWN:
					zmod -= 10;
					
					break;
			
			
			}
			
			break;

		case GLUT_ACTIVE_ALT:
			switch(key) {
				case GLUT_KEY_UP :
					scalemod += 0.1;
					
					break;
				case GLUT_KEY_DOWN :
					scalemod -= 0.1;
					
					break;
			}

			break;
			
		default:
		
			switch(key) {
			case GLUT_KEY_UP :
					roll += 0.1f;
					break;
			case GLUT_KEY_DOWN :
					roll -= 0.1f;
					break;
			case GLUT_KEY_RIGHT :
					yaw += 0.1f;
					break;
		
			case GLUT_KEY_LEFT :
					yaw -= 0.1f;
					break;
				
			case GLUT_KEY_PAGE_UP:
					pitch += 0.1f;
					break;
				
			case GLUT_KEY_PAGE_DOWN:
					pitch -= 0.1f;
					break;
		
			case GLUT_KEY_F1:
					mode =0;
					once = false;
					break;
				
			case GLUT_KEY_F2:
					mode=1;
					once = false;
					break;

			case GLUT_KEY_F3:
					mode=2;
					break;

			case GLUT_KEY_F4:
					mode=3;
					break;
				
			case GLUT_KEY_F12:
					yaw = roll = pitch = 0;
					
					break;
			}
			break;
	}
}

void idle()
{
	
	glutPostRedisplay();
	

}


//Program entry point.
//argc is a count of the number of arguments (including the filename of the program).
//argv is a pointer to each c-style string.
int main(int argc, char **argv)
{

    cout << "Computer Graphics Assignment 1 Demo Program" << endl;

	if (argc >  1)  
	{
		trig.loadFile(argv[1]);
	}
	else 
	{
        cerr << "Usage:" << endl;
		cerr << argv[0] << " <filename> " << endl;
		exit(1);
	}

	//initialise OpenGL
	glutInit(&argc, argv);
	//Define the window size with the size specifed at the top of this file
	glutInitWindowSize(nRows, nCols);
	//Create the window for drawing with the title "SimpleExample"
	glutCreateWindow("CG-CW1");
	//Apply a 2D orthographic projection matrix, allowing you to draw
	//directly to pixels
	gluOrtho2D(-nRows/2, nRows/2, -(float)nCols/2,  (float)nCols/2);

	//Set the function demoDisplay (defined above) as the function that
	//is called when the window must display
	glutDisplayFunc(demoDisplay);// Callback function
    //similarly for keyboard input
    glutKeyboardFunc(demoKeyboardHandler);	
    glutSpecialFunc(processSpecialKeys);
    glutIdleFunc(idle);
	//Run the GLUT internal loop
	glutMainLoop();// Display everything and wait
}
